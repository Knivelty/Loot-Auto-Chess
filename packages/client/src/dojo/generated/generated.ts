/* Autogenerated file. Do not edit manually. */

// TODO: learn how to generate it
import { AccountInterface, CallData } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import { PieceChange, RoundResult } from "../types";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    function actions() {
        const contract_name = "home";

        const spawn = async ({ account }: { account: AccountInterface }) => {
            try {
                return await provider.execute(
                    account,
                    contract_name,
                    "spawn",
                    []
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };

        const startBattle = async ({
            account,
        }: {
            account: AccountInterface;
        }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "startBattle",
                    []
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        const commitPreparation = async ({
            account,
            changes,
            result,
        }: {
            account: AccountInterface;
            changes: PieceChange[];
            result: RoundResult;
        }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "commitPreparation",
                    CallData.compile({ changes: changes, result: result })
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing commit preparation:", error);
                throw error;
            }
        };

        const nextRound = async ({ account }: { account: AccountInterface }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "nextRound",
                    []
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        const refreshAltar = async ({ account }: { account: AccountInterface }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "refreshAltar",
                    []
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        const getCoin = async ({ account }: { account: AccountInterface }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "getCoin",
                    []
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        const buyExp = async ({ account }: { account: AccountInterface }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "buyExp",
                    []
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing buyExp:", error);
                throw error;
            }
        };

        const buyHero = async ({
            account,
            altarSlot,
            invSlot,
        }: {
            account: AccountInterface;
            altarSlot: number;
            invSlot: number;
        }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "buyHero",
                    [altarSlot, invSlot]
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        const sellHero = async ({
            account,
            gid,
        }: {
            account: AccountInterface;
            gid: number;
        }) => {
            try {
                const { transaction_hash: txHash } = await provider.execute(
                    account,
                    contract_name,
                    "sellHero",
                    [gid]
                );

                const receipt = provider.provider.waitForTransaction(txHash);

                return { txHash, receipt };
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };

        return {
            spawn,
            startBattle,
            nextRound,
            refreshAltar,
            getCoin,
            buyHero,
            buyExp,
            sellHero,
            commitPreparation,
        };
    }
    return {
        actions: actions(),
        provider,
    };
}
